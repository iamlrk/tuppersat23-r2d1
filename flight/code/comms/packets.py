from ucollections import namedtuple
from code.comms.time_keeper import time_since_epoch
import time

Time = namedtuple('Time', 'hour minute second microsecond')

def generated_to_required(timer, group, packet, client_specified_format):
    """
    Converts a packet generated by a sensor device to a format required by a client.

    Args:
        time (float): The timestamp of the packet.
        group (str): The group identifier of the sensor device.
        packet (Packet): The packet generated by the sensor device.
        client_specified_format (str): The format specified by the client, either 'ucd' or 'r2d1'.

    Returns:
        Union[Packet, Dict[str, Any], Tuple[float, str, float, float, float, float, float]]: The converted packet in the format specified by the client.
        If the client format is 'ucd', a dictionary with the following keys:
            - 'hhmmss': The time of day in HHMMSS format.
            - 'latitude': The latitude of the sensor device.
            - 'longitude': The longitude of the sensor device.
            - 'hdop': The horizontal dilution of precision of the GPS measurement.
            - 'altitude': The altitude of the sensor device.
            - 't_internal': The internal temperature of the sensor device.
            - 't_external': The external temperature of the sensor device.
            - 'pressure': The atmospheric pressure measured by the sensor device.
        If the client format is 'r2d1', a tuple with the following values:
            - The timestamp of the packet, rounded to 2 decimal places.
            - The time of day in HHMMSS format.
            - The altitude of the sensor device.
            - The UVA radiation measured by the sensor device.
            - The UVB radiation measured by the sensor device.
            - The relative humidity measured by the sensor device.
            - The temperature measured by the humidity sensor of the device.
        If the client format is neither 'ucd' nor 'r2d1', the original packet is returned.
    """
    if client_specified_format.lower() == 'ucd':
        
        _pack = {
            'hhmmss': [parse_time(packet.gps.get('hhmmss'))][0],
            'latitude': [packet.gps.get('latitude')][0],
            'longitude': [packet.gps.get('longitude')][0],
            'hdop': [float(packet.gps.get('hdop'))][0],
            'altitude': [float(packet.gps.get('altitude'))][0],
            't_internal': [packet.temperature.get('temperature')[0]][0],
            't_external': [packet.temperature.get('temperature')[-1]][0],
            'pressure': [packet.pressure.get('pressure')/100][0],
            }
    
    elif client_specified_format.lower() == 'r2d1':
        _pack = [(round(timer, 2),
                    int(float(packet.gps.get('hhmmss'))),
                    float(packet.gps.get('altitude')),
                    packet.uv.get('uva'),
                    packet.uv.get('uvb'),
                    packet.humidity.get('humidity'),
                    packet.humidity.get('temperature'))][0]
    else:
        _pack = packet
    
    return _pack

def put_in_dict(group, packet):
    """
    Converts a packet into a dictionary or string representation, depending on the specified group.

    Args:
    - group (str): The group to which the packet belongs (either "telemetry" or "data").
    - packet (Union[List[Any], Any]): The packet to be converted.

    Returns:
    - packet (dict or string): The converted packet. If the group is "telemetry", a dictionary with the first item
    of the packet is returned. If the group is "data", a string representation of the packet without brackets is returned.
    Otherwise, the first item of the packet is returned.
    """
    if group == 'telemetry':
        return packet[0]
    
    if group == 'data':
        return str(packet).strip('[]')
    
    else:
        return packet[0]
    

def lat_long_fix(latlong):
    """
    Fixes the latitude/longitude coordinates by converting them to floating-point numbers and accounting for
    direction (north/south or east/west).

    Args:
        latlong (str): A string representing the latitude or longitude coordinate in the format 'DDMM.MMMMx',
            where 'DD' represents degrees and 'MMMM' represents minutes, and 'x' is either 'N', 'S', 'E', or 'W'.

    Returns:
        float: A floating-point number representing the latitude or longitude coordinate with the correct sign.
            If 'x' is 'N' or 'E', the value will be positive. If 'x' is 'S' or 'W', the value will be negative.
    """
    # print(latlong[-1].lower())
    if latlong[-1].lower() in ['e', 'n']:
        return float(latlong[:-1])
    elif latlong[-1].lower() in ['w', 's']:
        return -1*float(latlong[:-1])

def fix_time(time_named_tuple):
    """
    Converts time in named tuple format to integer format.

    Args:
    time_named_tuple (named tuple): Time in named tuple format (hours, minutes, seconds, microseconds)

    Returns:
    int: Time in integer format (HHMMSS)
    """
    return int(''.join((str(i) for i in tuple(time_named_tuple)))[:-1])

def package_it(timer, group, packet, packet_order=None, delimiter=','):
    """
    Package a dictionary of data with a specified order of keys into a delimited string.

    Args:
    group (str): A string indicating the group of data (e.g. "telemetry", "data").
    packet (dict): A dictionary containing the data to be packaged.
    packet_order (dict, optional): A dictionary specifying the order of keys to package the data. Defaults to None.
    delimiter (str, optional): The delimiter to use between each value. Defaults to '/'.

    Returns:
    str: A delimited string of the data in the specified order.

    """
    if packet_order is None:
        packet_order = {
            'telemetry': ['hhmmss', 'latitude', 'longitude', 'hdop', 'altitude', 't_internal', 't_external', 'pressure', 'temperature_from_pressure'],
        }
    if group == 'telemetry':
        _pack = {
            'hhmmss': [int(float(packet.gps.get('hhmmss')))][0],
            'latitude': [packet.gps.get('latitude')][0],
            'longitude': [packet.gps.get('longitude')][0],
            'hdop': [float(packet.gps.get('hdop'))][0],
            'altitude': [float(packet.gps.get('altitude'))][0],
            't_internal': [packet.temperature.get('temperature')[0]][0],
            't_external': [packet.temperature.get('temperature')[-1]][0],
            'pressure': [packet.pressure.get('pressure')/100][0],
            'temperature_from_pressure': [packet.pressure.get('temperature')][0],
            }
        # time = packet['hhmmss']
        # _temp['hhmmss'] = fix_time(_time)
        return (delimiter.join(str(_pack[order]) for order in packet_order.get(group)))
    elif group == 'data':
        _pack = [(round(timer, 2),
                    int(float(packet.gps.get('hhmmss'))),
                    float(packet.gps.get('altitude')),
                    packet.uv.get('uva'),
                    packet.uv.get('uvb'),
                    packet.humidity.get('humidity'),
                    packet.humidity.get('temperature'))][0]
        packet = str(_pack).strip('[]').strip('()')
        return packet

def chunk(string, n):
    """Break a string into chunks of length n."""
    return (string[i:i+n] for i in range(0, len(string), n))

def parse_time(time_str):
    """Parse a time string HHMMSS.SSS into a Time object."""

    # split out the second and sub-second times
    _hhmmss, _milliseconds = time_str.split('.')

    # compute the sub-second time in microseconds
    _us = int(_milliseconds) * 1000

    # compute the hours, minutes and seconds
    _hh, _mm, _ss = (int(x) for x in chunk(_hhmmss, 2))

    return Time(_hh, _mm, _ss, _us)

def main():
    dp = {'data':{
        'hhmmss': [120000, 120000, 120000, 120000, 120000],
        'altitude': [12000, 12000, 12000, 12000, 12000],
        'uva': [12000, 12000, 12000, 12000, 12000],
        'uvb': [12000, 12000, 12000, 12000, 12000],
        'humidity': [12000, 12000, 12000, 12000, 12000],
        'temperature': [12000, 12000, 12000, 12000, 12000],
        },
          'telemetry':{
                'hhmmss': 120000,
                'latitude': 120000,
                'longitude': 120000,
                'hdop': 120000,
                'altitude': 120000,
                't_internal': 120000,
                't_external': 120000,
                'pressure': 120000,
        }
    }
    return package_it(**dp)

if __name__ == '__main__':
    print(len(main()['data']))
    # main()
    pass

    a = {
        'storage': {
            'time': [1679352335, 1679352338, 1679352340],
            'sdcard': [None, None, None]
        },
        'data': {
            'time': [1679352335, 1679352337, 1679352340],
            'humidity': [((24695, 36902), 20.94377), ((24695, 36866), 20.94377), ((24700, 36841), 20.93042)],
            'uv': [(0.0, 0.0), (0.0, 0.0), (0.0, 0.0)]},
        'telemetry': {
            'time': [1679352335, 1679352338, 1679352340],
            'temperature': [21.0, 21.5625, 21.5625],
            'pressure': [(99999999,), (99999999,), (99999999,)]
        }
    }



